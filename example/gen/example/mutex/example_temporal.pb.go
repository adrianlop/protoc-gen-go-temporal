// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 0.7.6-next (7d735dedeb4c87868fef6815cc91ee8a47e44e4b)
//	go go1.20.4
//	protoc (unknown)
//
// source: example/mutex/example.proto
package mutex

import (
	"context"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	v1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
)

// MutexTaskQueue is the default task-queue for a Mutex worker
const MutexTaskQueue = "mutex-v1"

// Mutex workflow names
const (
	MutexWorkflowName                   = "mycompany.mutex.Mutex.Mutex"
	SampleWorkflowWithMutexWorkflowName = "mycompany.mutex.Mutex.SampleWorkflowWithMutex"
)

// Mutex workflow id expressions
var (
	MutexIDExpression                   = expression.MustParseExpression("mutex/${!resource}")
	SampleWorkflowWithMutexIDExpression = expression.MustParseExpression("sample-workflow-with-mutex/${!resource}/${!uuid_v4()}")
)

// Mutex workflow search attribute mappings
var (
	SampleWorkflowWithMutexSearchAttributesMapping = expression.MustParseMapping("resource = resource.not_empty().catch(\"unknown\")\nfoo = \"bar\"\n")
)

// Mutex activity names
const (
	MutexActivityName = "mycompany.mutex.Mutex.Mutex"
)

// Mutex signal names
const (
	AcquireLeaseSignalName  = "mycompany.mutex.Mutex.AcquireLease"
	LeaseAcquiredSignalName = "mycompany.mutex.Mutex.LeaseAcquired"
	RenewLeaseSignalName    = "mycompany.mutex.Mutex.RenewLease"
	RevokeLeaseSignalName   = "mycompany.mutex.Mutex.RevokeLease"
)

// Client describes a client for a Mutex worker
type Client interface {
	// Mutex provides a mutex over a shared resource
	Mutex(ctx context.Context, req *MutexRequest, opts ...*client.StartWorkflowOptions) error
	// MutexAsync starts a(n) Mutex workflow
	MutexAsync(ctx context.Context, req *MutexRequest, opts ...*client.StartWorkflowOptions) (MutexRun, error)
	// GetMutex retrieves a(n) existing Mutex workflow execution
	GetMutex(ctx context.Context, workflowID string, runID string) (MutexRun, error)
	// MutexWithAcquireLease sends a(n) AcquireLease signal to a Mutex workflow, starting it if not present
	MutexWithAcquireLease(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, opts ...*client.StartWorkflowOptions) error
	// MutexWithAcquireLeaseAsync sends a(n) AcquireLease signal to a Mutex workflow, starting it if not present
	MutexWithAcquireLeaseAsync(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, opts ...*client.StartWorkflowOptions) (MutexRun, error)
	// SampleWorkflowWithMutex provides an example of a running workflow that uses
	// a Mutex workflow to prevent concurrent access to a shared resource
	SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexRequest, opts ...*client.StartWorkflowOptions) (*SampleWorkflowWithMutexResponse, error)
	// SampleWorkflowWithMutexAsync starts a(n) SampleWorkflowWithMutex workflow
	SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexRequest, opts ...*client.StartWorkflowOptions) (SampleWorkflowWithMutexRun, error)
	// GetSampleWorkflowWithMutex retrieves a(n) existing SampleWorkflowWithMutex workflow execution
	GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) (SampleWorkflowWithMutexRun, error)
	// AcquireLease sends a AcquireLease signal to an existing workflow
	AcquireLease(ctx context.Context, workflowID string, runID string, signal *AcquireLeaseRequest) error
	// LeaseAcquired sends a LeaseAcquired signal to an existing workflow
	LeaseAcquired(ctx context.Context, workflowID string, runID string, signal *LeaseAcquiredRequest) error
	// RenewLease sends a RenewLease signal to an existing workflow
	RenewLease(ctx context.Context, workflowID string, runID string, signal *RenewLeaseRequest) error
	// RevokeLease sends a RevokeLease signal to an existing workflow
	RevokeLease(ctx context.Context, workflowID string, runID string, signal *RevokeLeaseRequest) error
}

// workflowClient implements a temporal client for a Mutex service
type workflowClient struct {
	client client.Client
}

// NewClient initializes a new Mutex client
func NewClient(c client.Client) Client {
	return &workflowClient{client: c}
}

// NewClientWithOptions initializes a new Mutex client with the given options
func NewClientWithOptions(c client.Client, opts client.Options) (Client, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	return &workflowClient{client: c}, nil
}

// Mutex provides a mutex over a shared resource
func (c *workflowClient) Mutex(ctx context.Context, req *MutexRequest, options ...*client.StartWorkflowOptions) error {
	run, err := c.MutexAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexAsync starts a Mutex workflow
func (c *workflowClient) MutexAsync(ctx context.Context, req *MutexRequest, options ...*client.StartWorkflowOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, MutexWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &mutexRun{
		client: c,
		run:    run,
	}, nil
}

// GetMutex fetches an existing Mutex execution
func (c *workflowClient) GetMutex(ctx context.Context, workflowID string, runID string) (MutexRun, error) {
	return &mutexRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}, nil
}

// MutexWithAcquireLease starts a Mutex workflow and sends a AcquireLease signal in a transaction
func (c *workflowClient) MutexWithAcquireLease(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, options ...*client.StartWorkflowOptions) error {
	run, err := c.MutexWithAcquireLeaseAsync(ctx, req, signal, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexWithAcquireLeaseAsync starts a Mutex workflow and sends a AcquireLease signal in a transaction
func (c *workflowClient) MutexWithAcquireLeaseAsync(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, options ...*client.StartWorkflowOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, AcquireLeaseSignalName, signal, *opts, MutexWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &mutexRun{
		client: c,
		run:    run,
	}, nil
}

// SampleWorkflowWithMutex provides an example of a running workflow that uses
// a Mutex workflow to prevent concurrent access to a shared resource
func (c *workflowClient) SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexRequest, options ...*client.StartWorkflowOptions) (*SampleWorkflowWithMutexResponse, error) {
	run, err := c.SampleWorkflowWithMutexAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SampleWorkflowWithMutexAsync starts a SampleWorkflowWithMutex workflow
func (c *workflowClient) SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexRequest, options ...*client.StartWorkflowOptions) (SampleWorkflowWithMutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	if opts.SearchAttributes == nil {
		structured, err := expression.ToStructured(req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error serializing input for \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		result, err := SampleWorkflowWithMutexSearchAttributesMapping.Query(structured)
		if err != nil {
			return nil, fmt.Errorf("error executing \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		searchAttributes, ok := result.(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("expected \"SampleWorkflowWithMutex\" search attribute mapping to return map[string]any, got: %T", result)
		}
		opts.SearchAttributes = searchAttributes
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SampleWorkflowWithMutexWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &sampleWorkflowWithMutexRun{
		client: c,
		run:    run,
	}, nil
}

// GetSampleWorkflowWithMutex fetches an existing SampleWorkflowWithMutex execution
func (c *workflowClient) GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) (SampleWorkflowWithMutexRun, error) {
	return &sampleWorkflowWithMutexRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}, nil
}

// AcquireLease sends a AcquireLease signal to an existing workflow
func (c *workflowClient) AcquireLease(ctx context.Context, workflowID string, runID string, signal *AcquireLeaseRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, AcquireLeaseSignalName, signal)
}

// LeaseAcquired sends a LeaseAcquired signal to an existing workflow
func (c *workflowClient) LeaseAcquired(ctx context.Context, workflowID string, runID string, signal *LeaseAcquiredRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, LeaseAcquiredSignalName, signal)
}

// RenewLease sends a RenewLease signal to an existing workflow
func (c *workflowClient) RenewLease(ctx context.Context, workflowID string, runID string, signal *RenewLeaseRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, RenewLeaseSignalName, signal)
}

// RevokeLease sends a RevokeLease signal to an existing workflow
func (c *workflowClient) RevokeLease(ctx context.Context, workflowID string, runID string, signal *RevokeLeaseRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, RevokeLeaseSignalName, signal)
}

// MutexRun describes a Mutex workflow run
type MutexRun interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error
	// AcquireLease sends a AcquireLease signal to the workflow
	AcquireLease(ctx context.Context, req *AcquireLeaseRequest) error
	// RenewLease sends a RenewLease signal to the workflow
	RenewLease(ctx context.Context, req *RenewLeaseRequest) error
	// RevokeLease sends a RevokeLease signal to the workflow
	RevokeLease(ctx context.Context, req *RevokeLeaseRequest) error
}

// mutexRun provides an internal implementation of a MutexRun
type mutexRun struct {
	client *workflowClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *mutexRun) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *mutexRun) RunID() string {
	return r.run.GetRunID()
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *mutexRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// AcquireLease sends a AcquireLease signal to the workflow
func (r *mutexRun) AcquireLease(ctx context.Context, req *AcquireLeaseRequest) error {
	return r.client.AcquireLease(ctx, r.ID(), "", req)
}

// RenewLease sends a RenewLease signal to the workflow
func (r *mutexRun) RenewLease(ctx context.Context, req *RenewLeaseRequest) error {
	return r.client.RenewLease(ctx, r.ID(), "", req)
}

// RevokeLease sends a RevokeLease signal to the workflow
func (r *mutexRun) RevokeLease(ctx context.Context, req *RevokeLeaseRequest) error {
	return r.client.RevokeLease(ctx, r.ID(), "", req)
}

// SampleWorkflowWithMutexRun describes a SampleWorkflowWithMutex workflow run
type SampleWorkflowWithMutexRun interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SampleWorkflowWithMutexResponse, error)
	// LeaseAcquired sends a LeaseAcquired signal to the workflow
	LeaseAcquired(ctx context.Context, req *LeaseAcquiredRequest) error
}

// sampleWorkflowWithMutexRun provides an internal implementation of a SampleWorkflowWithMutexRun
type sampleWorkflowWithMutexRun struct {
	client *workflowClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *sampleWorkflowWithMutexRun) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *sampleWorkflowWithMutexRun) RunID() string {
	return r.run.GetRunID()
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *sampleWorkflowWithMutexRun) Get(ctx context.Context) (*SampleWorkflowWithMutexResponse, error) {
	var resp SampleWorkflowWithMutexResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// LeaseAcquired sends a LeaseAcquired signal to the workflow
func (r *sampleWorkflowWithMutexRun) LeaseAcquired(ctx context.Context, req *LeaseAcquiredRequest) error {
	return r.client.LeaseAcquired(ctx, r.ID(), "", req)
}

// Workflows provides methods for initializing new Mutex workflow values
type Workflows interface {
	// Mutex initializes a new MutexWorkflow value
	Mutex(ctx workflow.Context, input *MutexInput) (MutexWorkflow, error)
	// SampleWorkflowWithMutex initializes a new SampleWorkflowWithMutexWorkflow value
	SampleWorkflowWithMutex(ctx workflow.Context, input *SampleWorkflowWithMutexInput) (SampleWorkflowWithMutexWorkflow, error)
}

// RegisterWorkflows registers Mutex workflows with the given worker
func RegisterWorkflows(r worker.Registry, workflows Workflows) {
	RegisterMutexWorkflow(r, workflows.Mutex)
	RegisterSampleWorkflowWithMutexWorkflow(r, workflows.SampleWorkflowWithMutex)
}

// RegisterMutexWorkflow registers a Mutex workflow with the given worker
func RegisterMutexWorkflow(r worker.Registry, wf func(workflow.Context, *MutexInput) (MutexWorkflow, error)) {
	r.RegisterWorkflowWithOptions(buildMutex(wf), workflow.RegisterOptions{Name: MutexWorkflowName})
}

// buildMutex converts a Mutex workflow struct into a valid workflow function
func buildMutex(wf func(workflow.Context, *MutexInput) (MutexWorkflow, error)) func(workflow.Context, *MutexRequest) error {
	return (&mutex{wf}).Mutex
}

// mutex provides an Mutex method for calling the user's implementation
type mutex struct {
	ctor func(workflow.Context, *MutexInput) (MutexWorkflow, error)
}

// Mutex constructs a new Mutex value and executes it
func (w *mutex) Mutex(ctx workflow.Context, req *MutexRequest) error {
	input := &MutexInput{
		Req: req,
		AcquireLease: &AcquireLeaseSignal{
			Channel: workflow.GetSignalChannel(ctx, AcquireLeaseSignalName),
		},
		RenewLease: &RenewLeaseSignal{
			Channel: workflow.GetSignalChannel(ctx, RenewLeaseSignalName),
		},
		RevokeLease: &RevokeLeaseSignal{
			Channel: workflow.GetSignalChannel(ctx, RevokeLeaseSignalName),
		},
	}
	wf, err := w.ctor(ctx, input)
	if err != nil {
		return err
	}
	return wf.Execute(ctx)
}

// MutexInput describes the input to a Mutex workflow constructor
type MutexInput struct {
	Req          *MutexRequest
	AcquireLease *AcquireLeaseSignal
	RenewLease   *RenewLeaseSignal
	RevokeLease  *RevokeLeaseSignal
}

// Mutex provides a mutex over a shared resource
type MutexWorkflow interface {
	// Execute a Mutex workflow
	Execute(ctx workflow.Context) error
}

// MutexChild executes a child Mutex workflow
func MutexChild(ctx workflow.Context, req *MutexRequest, options ...*workflow.ChildWorkflowOptions) error {
	childRun, err := MutexChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// MutexChildAsync executes a child Mutex workflow
func MutexChildAsync(ctx workflow.Context, req *MutexRequest, options ...*workflow.ChildWorkflowOptions) (*MutexChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 {
		opts = options[0]
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(MutexIDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &MutexChildRun{Future: workflow.ExecuteChildWorkflow(ctx, MutexWorkflowName, req)}, nil
}

// MutexChildRun describes a child Mutex workflow run
type MutexChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *MutexChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *MutexChildRun) Select(sel workflow.Selector, fn func(MutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *MutexChildRun) SelectStart(sel workflow.Selector, fn func(MutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *MutexChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// AcquireLease sends the corresponding signal request to the child workflow
func (r *MutexChildRun) AcquireLease(ctx workflow.Context, input *AcquireLeaseRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, AcquireLeaseSignalName, input)
}

// RenewLease sends the corresponding signal request to the child workflow
func (r *MutexChildRun) RenewLease(ctx workflow.Context, input *RenewLeaseRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, RenewLeaseSignalName, input)
}

// RevokeLease sends the corresponding signal request to the child workflow
func (r *MutexChildRun) RevokeLease(ctx workflow.Context, input *RevokeLeaseRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, RevokeLeaseSignalName, input)
}

// RegisterSampleWorkflowWithMutexWorkflow registers a SampleWorkflowWithMutex workflow with the given worker
func RegisterSampleWorkflowWithMutexWorkflow(r worker.Registry, wf func(workflow.Context, *SampleWorkflowWithMutexInput) (SampleWorkflowWithMutexWorkflow, error)) {
	r.RegisterWorkflowWithOptions(buildSampleWorkflowWithMutex(wf), workflow.RegisterOptions{Name: SampleWorkflowWithMutexWorkflowName})
}

// buildSampleWorkflowWithMutex converts a SampleWorkflowWithMutex workflow struct into a valid workflow function
func buildSampleWorkflowWithMutex(wf func(workflow.Context, *SampleWorkflowWithMutexInput) (SampleWorkflowWithMutexWorkflow, error)) func(workflow.Context, *SampleWorkflowWithMutexRequest) (*SampleWorkflowWithMutexResponse, error) {
	return (&sampleWorkflowWithMutex{wf}).SampleWorkflowWithMutex
}

// sampleWorkflowWithMutex provides an SampleWorkflowWithMutex method for calling the user's implementation
type sampleWorkflowWithMutex struct {
	ctor func(workflow.Context, *SampleWorkflowWithMutexInput) (SampleWorkflowWithMutexWorkflow, error)
}

// SampleWorkflowWithMutex constructs a new SampleWorkflowWithMutex value and executes it
func (w *sampleWorkflowWithMutex) SampleWorkflowWithMutex(ctx workflow.Context, req *SampleWorkflowWithMutexRequest) (*SampleWorkflowWithMutexResponse, error) {
	input := &SampleWorkflowWithMutexInput{
		Req: req,
		LeaseAcquired: &LeaseAcquiredSignal{
			Channel: workflow.GetSignalChannel(ctx, LeaseAcquiredSignalName),
		},
	}
	wf, err := w.ctor(ctx, input)
	if err != nil {
		return nil, err
	}
	return wf.Execute(ctx)
}

// SampleWorkflowWithMutexInput describes the input to a SampleWorkflowWithMutex workflow constructor
type SampleWorkflowWithMutexInput struct {
	Req           *SampleWorkflowWithMutexRequest
	LeaseAcquired *LeaseAcquiredSignal
}

// SampleWorkflowWithMutex provides an example of a running workflow that uses
// a Mutex workflow to prevent concurrent access to a shared resource
type SampleWorkflowWithMutexWorkflow interface {
	// Execute a SampleWorkflowWithMutex workflow
	Execute(ctx workflow.Context) (*SampleWorkflowWithMutexResponse, error)
}

// SampleWorkflowWithMutexChild executes a child SampleWorkflowWithMutex workflow
func SampleWorkflowWithMutexChild(ctx workflow.Context, req *SampleWorkflowWithMutexRequest, options ...*workflow.ChildWorkflowOptions) (*SampleWorkflowWithMutexResponse, error) {
	childRun, err := SampleWorkflowWithMutexChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SampleWorkflowWithMutexChildAsync executes a child SampleWorkflowWithMutex workflow
func SampleWorkflowWithMutexChildAsync(ctx workflow.Context, req *SampleWorkflowWithMutexRequest, options ...*workflow.ChildWorkflowOptions) (*SampleWorkflowWithMutexChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 {
		opts = options[0]
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	if opts.SearchAttributes == nil {
		structured, err := expression.ToStructured(req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error serializing input for \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		result, err := SampleWorkflowWithMutexSearchAttributesMapping.Query(structured)
		if err != nil {
			return nil, fmt.Errorf("error executing \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		searchAttributes, ok := result.(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("expected \"SampleWorkflowWithMutex\" search attribute mapping to return map[string]any, got: %T", result)
		}
		opts.SearchAttributes = searchAttributes
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &SampleWorkflowWithMutexChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SampleWorkflowWithMutexWorkflowName, req)}, nil
}

// SampleWorkflowWithMutexChildRun describes a child SampleWorkflowWithMutex workflow run
type SampleWorkflowWithMutexChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SampleWorkflowWithMutexChildRun) Get(ctx workflow.Context) (*SampleWorkflowWithMutexResponse, error) {
	var resp SampleWorkflowWithMutexResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SampleWorkflowWithMutexChildRun) Select(sel workflow.Selector, fn func(SampleWorkflowWithMutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SampleWorkflowWithMutexChildRun) SelectStart(sel workflow.Selector, fn func(SampleWorkflowWithMutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SampleWorkflowWithMutexChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// LeaseAcquired sends the corresponding signal request to the child workflow
func (r *SampleWorkflowWithMutexChildRun) LeaseAcquired(ctx workflow.Context, input *LeaseAcquiredRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, LeaseAcquiredSignalName, input)
}

// AcquireLeaseSignal describes a AcquireLease signal
type AcquireLeaseSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a AcquireLease signal is received
func (s *AcquireLeaseSignal) Receive(ctx workflow.Context) (*AcquireLeaseRequest, bool) {
	var resp AcquireLeaseRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a AcquireLease signal without blocking
func (s *AcquireLeaseSignal) ReceiveAsync() *AcquireLeaseRequest {
	var resp AcquireLeaseRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a AcquireLease signal without blocking
func (s *AcquireLeaseSignal) Select(sel workflow.Selector, fn func(*AcquireLeaseRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// AcquireLeaseExternal sends a AcquireLease signal to an existing workflow
func AcquireLeaseExternal(ctx workflow.Context, workflowID string, runID string, req *AcquireLeaseRequest) error {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, AcquireLeaseSignalName, req).Get(ctx, nil)
}

// LeaseAcquiredSignal describes a LeaseAcquired signal
type LeaseAcquiredSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a LeaseAcquired signal is received
func (s *LeaseAcquiredSignal) Receive(ctx workflow.Context) (*LeaseAcquiredRequest, bool) {
	var resp LeaseAcquiredRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a LeaseAcquired signal without blocking
func (s *LeaseAcquiredSignal) ReceiveAsync() *LeaseAcquiredRequest {
	var resp LeaseAcquiredRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a LeaseAcquired signal without blocking
func (s *LeaseAcquiredSignal) Select(sel workflow.Selector, fn func(*LeaseAcquiredRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// LeaseAcquiredExternal sends a LeaseAcquired signal to an existing workflow
func LeaseAcquiredExternal(ctx workflow.Context, workflowID string, runID string, req *LeaseAcquiredRequest) error {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, LeaseAcquiredSignalName, req).Get(ctx, nil)
}

// RenewLeaseSignal describes a RenewLease signal
type RenewLeaseSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a RenewLease signal is received
func (s *RenewLeaseSignal) Receive(ctx workflow.Context) (*RenewLeaseRequest, bool) {
	var resp RenewLeaseRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a RenewLease signal without blocking
func (s *RenewLeaseSignal) ReceiveAsync() *RenewLeaseRequest {
	var resp RenewLeaseRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a RenewLease signal without blocking
func (s *RenewLeaseSignal) Select(sel workflow.Selector, fn func(*RenewLeaseRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// RenewLeaseExternal sends a RenewLease signal to an existing workflow
func RenewLeaseExternal(ctx workflow.Context, workflowID string, runID string, req *RenewLeaseRequest) error {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, RenewLeaseSignalName, req).Get(ctx, nil)
}

// RevokeLeaseSignal describes a RevokeLease signal
type RevokeLeaseSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a RevokeLease signal is received
func (s *RevokeLeaseSignal) Receive(ctx workflow.Context) (*RevokeLeaseRequest, bool) {
	var resp RevokeLeaseRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a RevokeLease signal without blocking
func (s *RevokeLeaseSignal) ReceiveAsync() *RevokeLeaseRequest {
	var resp RevokeLeaseRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a RevokeLease signal without blocking
func (s *RevokeLeaseSignal) Select(sel workflow.Selector, fn func(*RevokeLeaseRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// RevokeLeaseExternal sends a RevokeLease signal to an existing workflow
func RevokeLeaseExternal(ctx workflow.Context, workflowID string, runID string, req *RevokeLeaseRequest) error {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, RevokeLeaseSignalName, req).Get(ctx, nil)
}

// Activities describes available worker activites
type Activities interface {
	// Mutex provides a mutex over a shared resource
	Mutex(ctx context.Context, req *MutexRequest) error
}

// RegisterActivities registers activities with a worker
func RegisterActivities(r worker.Registry, activities Activities) {
	RegisterMutexActivity(r, activities.Mutex)
}

// RegisterMutexActivity registers a Mutex activity
func RegisterMutexActivity(r worker.Registry, fn func(context.Context, *MutexRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: MutexActivityName,
	})
}

// MutexFuture describes a Mutex activity execution
type MutexFuture struct {
	Future workflow.Future
}

// Get blocks on a Mutex execution, returning the response
func (f *MutexFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the Mutex completion to the selector, callback can be nil
func (f *MutexFuture) Select(sel workflow.Selector, fn func(*MutexFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Mutex provides a mutex over a shared resource
func Mutex(ctx workflow.Context, opts *workflow.ActivityOptions, req *MutexRequest) *MutexFuture {
	if opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts = &activityOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	return &MutexFuture{Future: workflow.ExecuteActivity(ctx, MutexActivityName, req)}
}

// Mutex provides a mutex over a shared resource
func MutexLocal(ctx workflow.Context, opts *workflow.LocalActivityOptions, fn func(context.Context, *MutexRequest) error, req *MutexRequest) *MutexFuture {
	if opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &activityOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	var activity any
	if fn == nil {
		activity = MutexActivityName
	} else {
		activity = fn
	}
	return &MutexFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
}

// TestClient provides a testsuite-compatible Client
type TestClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Workflows
}

var _ Client = &TestClient{}

// NewTestClient initializes a new TestClient value
func NewTestClient(env *testsuite.TestWorkflowEnvironment, workflows Workflows) *TestClient {
	return &TestClient{env, workflows}
}

// Mutex executes a(n) Mutex workflow in the test environment
func (c *TestClient) Mutex(ctx context.Context, req *MutexRequest, opts ...*client.StartWorkflowOptions) error {
	run, err := c.MutexAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexAsync executes a(n) Mutex workflow in the test environment
func (c *TestClient) MutexAsync(ctx context.Context, req *MutexRequest, options ...*client.StartWorkflowOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	return &testMutexRun{env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetMutex is a noop
func (c *TestClient) GetMutex(ctx context.Context, workflowID string, runID string) (MutexRun, error) {
	return &testMutexRun{env: c.env, workflows: c.workflows}, nil
}

// MutexWithAcquireLease sends a(n) AcquireLease signal to a(n) Mutex workflow, starting it if necessary
func (c *TestClient) MutexWithAcquireLease(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, opts ...*client.StartWorkflowOptions) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(AcquireLeaseSignalName, signal)
	}, 0)
	return c.Mutex(ctx, req, opts...)
}

// MutexWithAcquireLeaseAsync sends a(n) AcquireLease signal to a(n) Mutex workflow, starting it if necessary
func (c *TestClient) MutexWithAcquireLeaseAsync(ctx context.Context, req *MutexRequest, signal *AcquireLeaseRequest, opts ...*client.StartWorkflowOptions) (*testMutexRun, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.AcquireLease(ctx, "", "", signal)
	}, 0)
	return c.MutexAsync(ctx, req, opts...)
}

// SampleWorkflowWithMutex executes a(n) SampleWorkflowWithMutex workflow in the test environment
func (c *TestClient) SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexRequest, opts ...*client.StartWorkflowOptions) (*SampleWorkflowWithMutexResponse, error) {
	run, err := c.SampleWorkflowWithMutexAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SampleWorkflowWithMutexAsync executes a(n) SampleWorkflowWithMutex workflow in the test environment
func (c *TestClient) SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexRequest, options ...*client.StartWorkflowOptions) (SampleWorkflowWithMutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "mutex-v1"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	if opts.SearchAttributes == nil {
		structured, err := expression.ToStructured(req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error serializing input for \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		result, err := SampleWorkflowWithMutexSearchAttributesMapping.Query(structured)
		if err != nil {
			return nil, fmt.Errorf("error executing \"SampleWorkflowWithMutex\" search attribute mapping: %v", err)
		}
		searchAttributes, ok := result.(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("expected \"SampleWorkflowWithMutex\" search attribute mapping to return map[string]any, got: %T", result)
		}
		opts.SearchAttributes = searchAttributes
	}
	return &testSampleWorkflowWithMutexRun{env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetSampleWorkflowWithMutex is a noop
func (c *TestClient) GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) (SampleWorkflowWithMutexRun, error) {
	return &testSampleWorkflowWithMutexRun{env: c.env, workflows: c.workflows}, nil
}

// AcquireLease executes a AcquireLease signal
func (c *TestClient) AcquireLease(ctx context.Context, workflowID string, runID string, req *AcquireLeaseRequest) error {
	c.env.SignalWorkflow(AcquireLeaseSignalName, req)
	return nil
}

// LeaseAcquired executes a LeaseAcquired signal
func (c *TestClient) LeaseAcquired(ctx context.Context, workflowID string, runID string, req *LeaseAcquiredRequest) error {
	c.env.SignalWorkflow(LeaseAcquiredSignalName, req)
	return nil
}

// RenewLease executes a RenewLease signal
func (c *TestClient) RenewLease(ctx context.Context, workflowID string, runID string, req *RenewLeaseRequest) error {
	c.env.SignalWorkflow(RenewLeaseSignalName, req)
	return nil
}

// RevokeLease executes a RevokeLease signal
func (c *TestClient) RevokeLease(ctx context.Context, workflowID string, runID string, req *RevokeLeaseRequest) error {
	c.env.SignalWorkflow(RevokeLeaseSignalName, req)
	return nil
}

var _ MutexRun = &testMutexRun{}

// testMutexRun provides convenience methods for interacting with a(n) Mutex workflow in the test environment
type testMutexRun struct {
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *MutexRequest
	workflows Workflows
}

// Get retrieves a test Mutex workflow result
func (r *testMutexRun) Get(context.Context) error {
	r.env.ExecuteWorkflow(buildMutex(r.workflows.Mutex), r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	return nil
}

// ID returns a test Mutex workflow run's workflow ID
func (r *testMutexRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testMutexRun) RunID() string {
	return ""
}

// AcquireLease executes a AcquireLease signal against a test Mutex workflow
func (r *testMutexRun) AcquireLease(ctx context.Context, req *AcquireLeaseRequest) error {
	return c.AcquireLease(ctx, "", "", req)
}

// RenewLease executes a RenewLease signal against a test Mutex workflow
func (r *testMutexRun) RenewLease(ctx context.Context, req *RenewLeaseRequest) error {
	return c.RenewLease(ctx, "", "", req)
}

// RevokeLease executes a RevokeLease signal against a test Mutex workflow
func (r *testMutexRun) RevokeLease(ctx context.Context, req *RevokeLeaseRequest) error {
	return c.RevokeLease(ctx, "", "", req)
}

var _ SampleWorkflowWithMutexRun = &testSampleWorkflowWithMutexRun{}

// testSampleWorkflowWithMutexRun provides convenience methods for interacting with a(n) SampleWorkflowWithMutex workflow in the test environment
type testSampleWorkflowWithMutexRun struct {
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SampleWorkflowWithMutexRequest
	workflows Workflows
}

// Get retrieves a test SampleWorkflowWithMutex workflow result
func (r *testSampleWorkflowWithMutexRun) Get(context.Context) (*SampleWorkflowWithMutexResponse, error) {
	r.env.ExecuteWorkflow(buildSampleWorkflowWithMutex(r.workflows.SampleWorkflowWithMutex), r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	var result SampleWorkflowWithMutexResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test SampleWorkflowWithMutex workflow run's workflow ID
func (r *testSampleWorkflowWithMutexRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testSampleWorkflowWithMutexRun) RunID() string {
	return ""
}

// LeaseAcquired executes a LeaseAcquired signal against a test SampleWorkflowWithMutex workflow
func (r *testSampleWorkflowWithMutexRun) LeaseAcquired(ctx context.Context, req *LeaseAcquiredRequest) error {
	return c.LeaseAcquired(ctx, "", "", req)
}
